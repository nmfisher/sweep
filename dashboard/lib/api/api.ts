// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * Sweep API
 * API definitions for the Sweep server/dashboard.
 *
 * OpenAPI spec version: 1.0.0-oas3
 * Contact: contact@avinium.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface BaseMessage
 */
export interface BaseMessage {
    /**
     * 
     * @type {string}
     * @memberof BaseMessage
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof BaseMessage
     */
    content: string;
    /**
     * 
     * @type {string}
     * @memberof BaseMessage
     */
    subject?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseMessage
     */
    fromAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseMessage
     */
    fromName?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseMessage
     */
    sendTo: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BaseMessage
     */
    organizationId: string;
}

/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    eventName: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Event
     */
    params?: { [key: string]: any; };
    /**
     * 
     * @type {Date}
     * @memberof Event
     */
    receivedOn: Date;
    /**
     * 
     * @type {Date}
     * @memberof Event
     */
    processedOn?: Date;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    error?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    organizationId: string;
    /**
     * 
     * @type {Array<ListenerAction>}
     * @memberof Event
     */
    actions?: Array<ListenerAction>;
}

/**
 * 
 * @export
 * @interface EventRequestBody
 */
export interface EventRequestBody {
    /**
     * 
     * @type {string}
     * @memberof EventRequestBody
     */
    eventName: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof EventRequestBody
     */
    params?: { [key: string]: any; };
}

/**
 * 
 * @export
 * @interface Listener
 */
export interface Listener {
    /**
     * 
     * @type {string}
     * @memberof Listener
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Listener
     */
    eventName: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Listener
     */
    eventParams?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Listener
     */
    organizationId: string;
    /**
     * 
     * @type {string}
     * @memberof Listener
     */
    trigger?: string;
}

/**
 * 
 * @export
 * @interface ListenerAction
 */
export interface ListenerAction {
    /**
     * 
     * @type {string}
     * @memberof ListenerAction
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ListenerAction
     */
    eventId: string;
    /**
     * 
     * @type {string}
     * @memberof ListenerAction
     */
    listenerId: string;
    /**
     * 
     * @type {string}
     * @memberof ListenerAction
     */
    organizationId: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListenerAction
     */
    completed: boolean;
    /**
     * 
     * @type {string}
     * @memberof ListenerAction
     */
    error?: string;
}

/**
 * 
 * @export
 * @interface ListenerRequestBody
 */
export interface ListenerRequestBody {
    /**
     * 
     * @type {string}
     * @memberof ListenerRequestBody
     */
    eventName: string;
    /**
     * 
     * @type {string}
     * @memberof ListenerRequestBody
     */
    trigger?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListenerRequestBody
     */
    eventParams?: Array<string>;
}

/**
 * 
 * @export
 * @interface ListenerTemplate
 */
export interface ListenerTemplate {
    /**
     * 
     * @type {string}
     * @memberof ListenerTemplate
     */
    listenerId: string;
    /**
     * 
     * @type {string}
     * @memberof ListenerTemplate
     */
    templateId: string;
    /**
     * 
     * @type {string}
     * @memberof ListenerTemplate
     */
    organizationId: string;
}

/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    content: string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    subject: string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    fromAddress: string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    fromName: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Message
     */
    sendTo: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    organizationId: string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    listenerActionId: string;
    /**
     * 
     * @type {Date}
     * @memberof Message
     */
    sentOn?: Date;
}

/**
 * 
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    primaryApiKey: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    secondaryApiKey: string;
}

/**
 * 
 * @export
 * @interface RenderTemplateRequestBody
 */
export interface RenderTemplateRequestBody {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof RenderTemplateRequestBody
     */
    params?: { [key: string]: any; };
}

/**
 * 
 * @export
 * @interface Template
 */
export interface Template {
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    content: string;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    subject?: string;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    fromAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    fromName?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Template
     */
    sendTo: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    organizationId: string;
    /**
     * 
     * @type {boolean}
     * @memberof Template
     */
    deleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    userId: string;
}

/**
 * 
 * @export
 * @interface TemplateRequestBody
 */
export interface TemplateRequestBody {
    /**
     * 
     * @type {string}
     * @memberof TemplateRequestBody
     */
    content: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateRequestBody
     */
    subject: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateRequestBody
     */
    fromAddress: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateRequestBody
     */
    fromName: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TemplateRequestBody
     */
    sendTo: Array<string>;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    organizationId: string;
}

/**
 * 
 * @export
 * @interface UserRequestBody
 */
export interface UserRequestBody {
    /**
     * 
     * @type {string}
     * @memberof UserRequestBody
     */
    username: string;
}


/**
 * EventApi - axios parameter creator
 * @export
 */
export const EventApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Raise an event
         * @param {EventRequestBody} eventRequestBody 
         * @param {string} [apiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEvent(eventRequestBody: EventRequestBody, apiKey?: string, options: any = {}): RequestArgs {
            // verify required parameter 'eventRequestBody' is not null or undefined
            if (eventRequestBody === null || eventRequestBody === undefined) {
                throw new RequiredError('eventRequestBody','Required parameter eventRequestBody was null or undefined when calling addEvent.');
            }
            const localVarPath = `/events`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("api_key")
                    : configuration.apiKey;
                localVarHeaderParameter["api_key"] = localVarApiKeyValue;
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"EventRequestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(eventRequestBody !== undefined ? eventRequestBody : {}) : (eventRequestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find raised event by ID
         * @param {string} eventId ID of event that needs to be fetched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventById(eventId: string, options: any = {}): RequestArgs {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling getEventById.');
            }
            const localVarPath = `/events/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all events
         * @summary List all received events
         * @param {boolean} [withActions] 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents(withActions?: boolean, startDate?: Date, endDate?: Date, options: any = {}): RequestArgs {
            const localVarPath = `/events`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Google required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("Google", ["https://www.googleapis.com/auth/userinfo.email"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (withActions !== undefined) {
                localVarQueryParameter['withActions'] = withActions;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventApi - functional programming interface
 * @export
 */
export const EventApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Raise an event
         * @param {EventRequestBody} eventRequestBody 
         * @param {string} [apiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEvent(eventRequestBody: EventRequestBody, apiKey?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = EventApiAxiosParamCreator(configuration).addEvent(eventRequestBody, apiKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Find raised event by ID
         * @param {string} eventId ID of event that needs to be fetched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventById(eventId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event> {
            const localVarAxiosArgs = EventApiAxiosParamCreator(configuration).getEventById(eventId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of all events
         * @summary List all received events
         * @param {boolean} [withActions] 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents(withActions?: boolean, startDate?: Date, endDate?: Date, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>> {
            const localVarAxiosArgs = EventApiAxiosParamCreator(configuration).listEvents(withActions, startDate, endDate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EventApi - factory interface
 * @export
 */
export const EventApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Raise an event
         * @param {EventRequestBody} eventRequestBody 
         * @param {string} [apiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEvent(eventRequestBody: EventRequestBody, apiKey?: string, options?: any) {
            return EventApiFp(configuration).addEvent(eventRequestBody, apiKey, options)(axios, basePath);
        },
        /**
         * 
         * @summary Find raised event by ID
         * @param {string} eventId ID of event that needs to be fetched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventById(eventId: string, options?: any) {
            return EventApiFp(configuration).getEventById(eventId, options)(axios, basePath);
        },
        /**
         * Returns a list of all events
         * @summary List all received events
         * @param {boolean} [withActions] 
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents(withActions?: boolean, startDate?: Date, endDate?: Date, options?: any) {
            return EventApiFp(configuration).listEvents(withActions, startDate, endDate, options)(axios, basePath);
        },
    };
};

/**
 * EventApi - object-oriented interface
 * @export
 * @class EventApi
 * @extends {BaseAPI}
 */
export class EventApi extends BaseAPI {
    /**
     * 
     * @summary Raise an event
     * @param {EventRequestBody} eventRequestBody 
     * @param {string} [apiKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public addEvent(eventRequestBody: EventRequestBody, apiKey?: string, options?: any) {
        return EventApiFp(this.configuration).addEvent(eventRequestBody, apiKey, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Find raised event by ID
     * @param {string} eventId ID of event that needs to be fetched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEventById(eventId: string, options?: any) {
        return EventApiFp(this.configuration).getEventById(eventId, options)(this.axios, this.basePath);
    }

    /**
     * Returns a list of all events
     * @summary List all received events
     * @param {boolean} [withActions] 
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public listEvents(withActions?: boolean, startDate?: Date, endDate?: Date, options?: any) {
        return EventApiFp(this.configuration).listEvents(withActions, startDate, endDate, options)(this.axios, this.basePath);
    }

}


/**
 * ListenerApi - axios parameter creator
 * @export
 */
export const ListenerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new Listener
         * @param {ListenerRequestBody} listenerRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addListener(listenerRequestBody: ListenerRequestBody, options: any = {}): RequestArgs {
            // verify required parameter 'listenerRequestBody' is not null or undefined
            if (listenerRequestBody === null || listenerRequestBody === undefined) {
                throw new RequiredError('listenerRequestBody','Required parameter listenerRequestBody was null or undefined when calling addListener.');
            }
            const localVarPath = `/listeners`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Google required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("Google", ["https://www.googleapis.com/auth/userinfo.email"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"ListenerRequestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(listenerRequestBody !== undefined ? listenerRequestBody : {}) : (listenerRequestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Associates a Template to a Listener
         * @param {string} listenerId Listener id to disassociate
         * @param {string} templateId Template id to associate with the Listener
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addListenerTemplate(listenerId: string, templateId: string, options: any = {}): RequestArgs {
            // verify required parameter 'listenerId' is not null or undefined
            if (listenerId === null || listenerId === undefined) {
                throw new RequiredError('listenerId','Required parameter listenerId was null or undefined when calling addListenerTemplate.');
            }
            // verify required parameter 'templateId' is not null or undefined
            if (templateId === null || templateId === undefined) {
                throw new RequiredError('templateId','Required parameter templateId was null or undefined when calling addListenerTemplate.');
            }
            const localVarPath = `/listeners/{listenerId}/templates/{templateId}`
                .replace(`{${"listenerId"}}`, encodeURIComponent(String(listenerId)))
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Google required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("Google", ["https://www.googleapis.com/auth/userinfo.email"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a Listener
         * @param {string} listenerId ID of listener to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteListener(listenerId: string, options: any = {}): RequestArgs {
            // verify required parameter 'listenerId' is not null or undefined
            if (listenerId === null || listenerId === undefined) {
                throw new RequiredError('listenerId','Required parameter listenerId was null or undefined when calling deleteListener.');
            }
            const localVarPath = `/listeners/{listenerId}`
                .replace(`{${"listenerId"}}`, encodeURIComponent(String(listenerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Google required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("Google", ["https://www.googleapis.com/auth/userinfo.email"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disassociates a Template from a Listener
         * @param {string} listenerId Listener id to disassociate
         * @param {string} templateId Template id to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteListenerTemplate(listenerId: string, templateId: string, options: any = {}): RequestArgs {
            // verify required parameter 'listenerId' is not null or undefined
            if (listenerId === null || listenerId === undefined) {
                throw new RequiredError('listenerId','Required parameter listenerId was null or undefined when calling deleteListenerTemplate.');
            }
            // verify required parameter 'templateId' is not null or undefined
            if (templateId === null || templateId === undefined) {
                throw new RequiredError('templateId','Required parameter templateId was null or undefined when calling deleteListenerTemplate.');
            }
            const localVarPath = `/listeners/{listenerId}/templates/{templateId}`
                .replace(`{${"listenerId"}}`, encodeURIComponent(String(listenerId)))
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Google required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("Google", ["https://www.googleapis.com/auth/userinfo.email"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a listener
         * @summary Get a listener by ID
         * @param {string} listenerId ID of listener to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListener(listenerId: string, options: any = {}): RequestArgs {
            // verify required parameter 'listenerId' is not null or undefined
            if (listenerId === null || listenerId === undefined) {
                throw new RequiredError('listenerId','Required parameter listenerId was null or undefined when calling getListener.');
            }
            const localVarPath = `/listeners/{listenerId}`
                .replace(`{${"listenerId"}}`, encodeURIComponent(String(listenerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Google required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("Google", ["https://www.googleapis.com/auth/userinfo.email"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of templates associated with this listener
         * @summary List Templates for Listener
         * @param {string} listenerId ID of listener
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listListenerTemplates(listenerId: string, options: any = {}): RequestArgs {
            // verify required parameter 'listenerId' is not null or undefined
            if (listenerId === null || listenerId === undefined) {
                throw new RequiredError('listenerId','Required parameter listenerId was null or undefined when calling listListenerTemplates.');
            }
            const localVarPath = `/listeners/{listenerId}/templates`
                .replace(`{${"listenerId"}}`, encodeURIComponent(String(listenerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Listeners
         * @summary List all Listeners
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listListeners(options: any = {}): RequestArgs {
            const localVarPath = `/listeners`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Google required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("Google", ["https://www.googleapis.com/auth/userinfo.email"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of messages for the given ListenerAction
         * @summary List all messages
         * @param {string} listenerActionId The id of the ListenerAction to limit the results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMessagesForAction(listenerActionId: string, options: any = {}): RequestArgs {
            // verify required parameter 'listenerActionId' is not null or undefined
            if (listenerActionId === null || listenerActionId === undefined) {
                throw new RequiredError('listenerActionId','Required parameter listenerActionId was null or undefined when calling listMessagesForAction.');
            }
            const localVarPath = `/actions/{listenerActionId}/messages`
                .replace(`{${"listenerActionId"}}`, encodeURIComponent(String(listenerActionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Google required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("Google", ["https://www.googleapis.com/auth/userinfo.email"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a Listener
         * @param {string} listenerId ID of listener to update
         * @param {ListenerRequestBody} listenerRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateListener(listenerId: string, listenerRequestBody: ListenerRequestBody, options: any = {}): RequestArgs {
            // verify required parameter 'listenerId' is not null or undefined
            if (listenerId === null || listenerId === undefined) {
                throw new RequiredError('listenerId','Required parameter listenerId was null or undefined when calling updateListener.');
            }
            // verify required parameter 'listenerRequestBody' is not null or undefined
            if (listenerRequestBody === null || listenerRequestBody === undefined) {
                throw new RequiredError('listenerRequestBody','Required parameter listenerRequestBody was null or undefined when calling updateListener.');
            }
            const localVarPath = `/listeners/{listenerId}`
                .replace(`{${"listenerId"}}`, encodeURIComponent(String(listenerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Google required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("Google", ["https://www.googleapis.com/auth/userinfo.email"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"ListenerRequestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(listenerRequestBody !== undefined ? listenerRequestBody : {}) : (listenerRequestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ListenerApi - functional programming interface
 * @export
 */
export const ListenerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new Listener
         * @param {ListenerRequestBody} listenerRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addListener(listenerRequestBody: ListenerRequestBody, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Listener> {
            const localVarAxiosArgs = ListenerApiAxiosParamCreator(configuration).addListener(listenerRequestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Associates a Template to a Listener
         * @param {string} listenerId Listener id to disassociate
         * @param {string} templateId Template id to associate with the Listener
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addListenerTemplate(listenerId: string, templateId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = ListenerApiAxiosParamCreator(configuration).addListenerTemplate(listenerId, templateId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes a Listener
         * @param {string} listenerId ID of listener to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteListener(listenerId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = ListenerApiAxiosParamCreator(configuration).deleteListener(listenerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Disassociates a Template from a Listener
         * @param {string} listenerId Listener id to disassociate
         * @param {string} templateId Template id to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteListenerTemplate(listenerId: string, templateId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = ListenerApiAxiosParamCreator(configuration).deleteListenerTemplate(listenerId, templateId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a listener
         * @summary Get a listener by ID
         * @param {string} listenerId ID of listener to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListener(listenerId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Listener> {
            const localVarAxiosArgs = ListenerApiAxiosParamCreator(configuration).getListener(listenerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of templates associated with this listener
         * @summary List Templates for Listener
         * @param {string} listenerId ID of listener
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listListenerTemplates(listenerId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListenerTemplate>> {
            const localVarAxiosArgs = ListenerApiAxiosParamCreator(configuration).listListenerTemplates(listenerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of Listeners
         * @summary List all Listeners
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listListeners(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Listener>> {
            const localVarAxiosArgs = ListenerApiAxiosParamCreator(configuration).listListeners(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of messages for the given ListenerAction
         * @summary List all messages
         * @param {string} listenerActionId The id of the ListenerAction to limit the results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMessagesForAction(listenerActionId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Message>> {
            const localVarAxiosArgs = ListenerApiAxiosParamCreator(configuration).listMessagesForAction(listenerActionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a Listener
         * @param {string} listenerId ID of listener to update
         * @param {ListenerRequestBody} listenerRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateListener(listenerId: string, listenerRequestBody: ListenerRequestBody, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Listener> {
            const localVarAxiosArgs = ListenerApiAxiosParamCreator(configuration).updateListener(listenerId, listenerRequestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ListenerApi - factory interface
 * @export
 */
export const ListenerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create a new Listener
         * @param {ListenerRequestBody} listenerRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addListener(listenerRequestBody: ListenerRequestBody, options?: any) {
            return ListenerApiFp(configuration).addListener(listenerRequestBody, options)(axios, basePath);
        },
        /**
         * 
         * @summary Associates a Template to a Listener
         * @param {string} listenerId Listener id to disassociate
         * @param {string} templateId Template id to associate with the Listener
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addListenerTemplate(listenerId: string, templateId: string, options?: any) {
            return ListenerApiFp(configuration).addListenerTemplate(listenerId, templateId, options)(axios, basePath);
        },
        /**
         * 
         * @summary Deletes a Listener
         * @param {string} listenerId ID of listener to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteListener(listenerId: string, options?: any) {
            return ListenerApiFp(configuration).deleteListener(listenerId, options)(axios, basePath);
        },
        /**
         * 
         * @summary Disassociates a Template from a Listener
         * @param {string} listenerId Listener id to disassociate
         * @param {string} templateId Template id to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteListenerTemplate(listenerId: string, templateId: string, options?: any) {
            return ListenerApiFp(configuration).deleteListenerTemplate(listenerId, templateId, options)(axios, basePath);
        },
        /**
         * Returns a listener
         * @summary Get a listener by ID
         * @param {string} listenerId ID of listener to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListener(listenerId: string, options?: any) {
            return ListenerApiFp(configuration).getListener(listenerId, options)(axios, basePath);
        },
        /**
         * Returns a list of templates associated with this listener
         * @summary List Templates for Listener
         * @param {string} listenerId ID of listener
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listListenerTemplates(listenerId: string, options?: any) {
            return ListenerApiFp(configuration).listListenerTemplates(listenerId, options)(axios, basePath);
        },
        /**
         * Returns a list of Listeners
         * @summary List all Listeners
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listListeners(options?: any) {
            return ListenerApiFp(configuration).listListeners(options)(axios, basePath);
        },
        /**
         * Returns a list of messages for the given ListenerAction
         * @summary List all messages
         * @param {string} listenerActionId The id of the ListenerAction to limit the results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMessagesForAction(listenerActionId: string, options?: any) {
            return ListenerApiFp(configuration).listMessagesForAction(listenerActionId, options)(axios, basePath);
        },
        /**
         * 
         * @summary Updates a Listener
         * @param {string} listenerId ID of listener to update
         * @param {ListenerRequestBody} listenerRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateListener(listenerId: string, listenerRequestBody: ListenerRequestBody, options?: any) {
            return ListenerApiFp(configuration).updateListener(listenerId, listenerRequestBody, options)(axios, basePath);
        },
    };
};

/**
 * ListenerApi - object-oriented interface
 * @export
 * @class ListenerApi
 * @extends {BaseAPI}
 */
export class ListenerApi extends BaseAPI {
    /**
     * 
     * @summary Create a new Listener
     * @param {ListenerRequestBody} listenerRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListenerApi
     */
    public addListener(listenerRequestBody: ListenerRequestBody, options?: any) {
        return ListenerApiFp(this.configuration).addListener(listenerRequestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Associates a Template to a Listener
     * @param {string} listenerId Listener id to disassociate
     * @param {string} templateId Template id to associate with the Listener
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListenerApi
     */
    public addListenerTemplate(listenerId: string, templateId: string, options?: any) {
        return ListenerApiFp(this.configuration).addListenerTemplate(listenerId, templateId, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Deletes a Listener
     * @param {string} listenerId ID of listener to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListenerApi
     */
    public deleteListener(listenerId: string, options?: any) {
        return ListenerApiFp(this.configuration).deleteListener(listenerId, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Disassociates a Template from a Listener
     * @param {string} listenerId Listener id to disassociate
     * @param {string} templateId Template id to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListenerApi
     */
    public deleteListenerTemplate(listenerId: string, templateId: string, options?: any) {
        return ListenerApiFp(this.configuration).deleteListenerTemplate(listenerId, templateId, options)(this.axios, this.basePath);
    }

    /**
     * Returns a listener
     * @summary Get a listener by ID
     * @param {string} listenerId ID of listener to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListenerApi
     */
    public getListener(listenerId: string, options?: any) {
        return ListenerApiFp(this.configuration).getListener(listenerId, options)(this.axios, this.basePath);
    }

    /**
     * Returns a list of templates associated with this listener
     * @summary List Templates for Listener
     * @param {string} listenerId ID of listener
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListenerApi
     */
    public listListenerTemplates(listenerId: string, options?: any) {
        return ListenerApiFp(this.configuration).listListenerTemplates(listenerId, options)(this.axios, this.basePath);
    }

    /**
     * Returns a list of Listeners
     * @summary List all Listeners
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListenerApi
     */
    public listListeners(options?: any) {
        return ListenerApiFp(this.configuration).listListeners(options)(this.axios, this.basePath);
    }

    /**
     * Returns a list of messages for the given ListenerAction
     * @summary List all messages
     * @param {string} listenerActionId The id of the ListenerAction to limit the results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListenerApi
     */
    public listMessagesForAction(listenerActionId: string, options?: any) {
        return ListenerApiFp(this.configuration).listMessagesForAction(listenerActionId, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Updates a Listener
     * @param {string} listenerId ID of listener to update
     * @param {ListenerRequestBody} listenerRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListenerApi
     */
    public updateListener(listenerId: string, listenerRequestBody: ListenerRequestBody, options?: any) {
        return ListenerApiFp(this.configuration).updateListener(listenerId, listenerRequestBody, options)(this.axios, this.basePath);
    }

}


/**
 * MessageApi - axios parameter creator
 * @export
 */
export const MessageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a single message
         * @summary Find message by ID
         * @param {string} messageId ID of message to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageById(messageId: string, options: any = {}): RequestArgs {
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new RequiredError('messageId','Required parameter messageId was null or undefined when calling getMessageById.');
            }
            const localVarPath = `/messages/{messageId}`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Google required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("Google", ["https://www.googleapis.com/auth/userinfo.email"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of messages
         * @summary List all messages
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMessages(startDate?: Date, endDate?: Date, options: any = {}): RequestArgs {
            const localVarPath = `/messages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Google required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("Google", ["https://www.googleapis.com/auth/userinfo.email"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessageApi - functional programming interface
 * @export
 */
export const MessageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a single message
         * @summary Find message by ID
         * @param {string} messageId ID of message to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageById(messageId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message> {
            const localVarAxiosArgs = MessageApiAxiosParamCreator(configuration).getMessageById(messageId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of messages
         * @summary List all messages
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMessages(startDate?: Date, endDate?: Date, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Message>> {
            const localVarAxiosArgs = MessageApiAxiosParamCreator(configuration).listMessages(startDate, endDate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MessageApi - factory interface
 * @export
 */
export const MessageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns a single message
         * @summary Find message by ID
         * @param {string} messageId ID of message to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageById(messageId: string, options?: any) {
            return MessageApiFp(configuration).getMessageById(messageId, options)(axios, basePath);
        },
        /**
         * Returns a list of messages
         * @summary List all messages
         * @param {Date} [startDate] 
         * @param {Date} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMessages(startDate?: Date, endDate?: Date, options?: any) {
            return MessageApiFp(configuration).listMessages(startDate, endDate, options)(axios, basePath);
        },
    };
};

/**
 * MessageApi - object-oriented interface
 * @export
 * @class MessageApi
 * @extends {BaseAPI}
 */
export class MessageApi extends BaseAPI {
    /**
     * Returns a single message
     * @summary Find message by ID
     * @param {string} messageId ID of message to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    public getMessageById(messageId: string, options?: any) {
        return MessageApiFp(this.configuration).getMessageById(messageId, options)(this.axios, this.basePath);
    }

    /**
     * Returns a list of messages
     * @summary List all messages
     * @param {Date} [startDate] 
     * @param {Date} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    public listMessages(startDate?: Date, endDate?: Date, options?: any) {
        return MessageApiFp(this.configuration).listMessages(startDate, endDate, options)(this.axios, this.basePath);
    }

}


/**
 * OrganizationApi - axios parameter creator
 * @export
 */
export const OrganizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get organization info for the currently authenticated context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInfo(options: any = {}): RequestArgs {
            const localVarPath = `/organization`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Google required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("Google", ["https://www.googleapis.com/auth/userinfo.email"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationApi - functional programming interface
 * @export
 */
export const OrganizationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get organization info for the currently authenticated context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInfo(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization> {
            const localVarAxiosArgs = OrganizationApiAxiosParamCreator(configuration).getOrganizationInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OrganizationApi - factory interface
 * @export
 */
export const OrganizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get organization info for the currently authenticated context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInfo(options?: any) {
            return OrganizationApiFp(configuration).getOrganizationInfo(options)(axios, basePath);
        },
    };
};

/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
export class OrganizationApi extends BaseAPI {
    /**
     * 
     * @summary Get organization info for the currently authenticated context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganizationInfo(options?: any) {
        return OrganizationApiFp(this.configuration).getOrganizationInfo(options)(this.axios, this.basePath);
    }

}


/**
 * TemplateApi - axios parameter creator
 * @export
 */
export const TemplateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new Template
         * @param {TemplateRequestBody} templateRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTemplate(templateRequestBody: TemplateRequestBody, options: any = {}): RequestArgs {
            // verify required parameter 'templateRequestBody' is not null or undefined
            if (templateRequestBody === null || templateRequestBody === undefined) {
                throw new RequiredError('templateRequestBody','Required parameter templateRequestBody was null or undefined when calling addTemplate.');
            }
            const localVarPath = `/templates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Google required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("Google", ["https://www.googleapis.com/auth/userinfo.email"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"TemplateRequestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(templateRequestBody !== undefined ? templateRequestBody : {}) : (templateRequestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a Template
         * @param {string} templateId Template id to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate(templateId: string, options: any = {}): RequestArgs {
            // verify required parameter 'templateId' is not null or undefined
            if (templateId === null || templateId === undefined) {
                throw new RequiredError('templateId','Required parameter templateId was null or undefined when calling deleteTemplate.');
            }
            const localVarPath = `/templates/{templateId}`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Google required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("Google", ["https://www.googleapis.com/auth/userinfo.email"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single template
         * @summary Find Template by ID
         * @param {string} templateId ID of template to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplateById(templateId: string, options: any = {}): RequestArgs {
            // verify required parameter 'templateId' is not null or undefined
            if (templateId === null || templateId === undefined) {
                throw new RequiredError('templateId','Required parameter templateId was null or undefined when calling getTemplateById.');
            }
            const localVarPath = `/templates/{templateId}`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of templates
         * @summary List all Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTemplate(options: any = {}): RequestArgs {
            const localVarPath = `/templates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Google required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("Google", ["https://www.googleapis.com/auth/userinfo.email"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a string representing the HTML content of an email to be sent
         * @summary Renders a template using the provided event parameters
         * @param {string} templateId ID of template to return
         * @param {RenderTemplateRequestBody} renderTemplateRequestBody The event parameters used to render
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renderTemplate(templateId: string, renderTemplateRequestBody: RenderTemplateRequestBody, options: any = {}): RequestArgs {
            // verify required parameter 'templateId' is not null or undefined
            if (templateId === null || templateId === undefined) {
                throw new RequiredError('templateId','Required parameter templateId was null or undefined when calling renderTemplate.');
            }
            // verify required parameter 'renderTemplateRequestBody' is not null or undefined
            if (renderTemplateRequestBody === null || renderTemplateRequestBody === undefined) {
                throw new RequiredError('renderTemplateRequestBody','Required parameter renderTemplateRequestBody was null or undefined when calling renderTemplate.');
            }
            const localVarPath = `/templates/{templateId}/render`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Google required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("Google", ["https://www.googleapis.com/auth/userinfo.email"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"RenderTemplateRequestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(renderTemplateRequestBody !== undefined ? renderTemplateRequestBody : {}) : (renderTemplateRequestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing Template
         * @param {string} templateId ID of template to return
         * @param {TemplateRequestBody} templateRequestBody successful operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplate(templateId: string, templateRequestBody: TemplateRequestBody, options: any = {}): RequestArgs {
            // verify required parameter 'templateId' is not null or undefined
            if (templateId === null || templateId === undefined) {
                throw new RequiredError('templateId','Required parameter templateId was null or undefined when calling updateTemplate.');
            }
            // verify required parameter 'templateRequestBody' is not null or undefined
            if (templateRequestBody === null || templateRequestBody === undefined) {
                throw new RequiredError('templateRequestBody','Required parameter templateRequestBody was null or undefined when calling updateTemplate.');
            }
            const localVarPath = `/templates/{templateId}`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Google required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("Google", ["https://www.googleapis.com/auth/userinfo.email"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"TemplateRequestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(templateRequestBody !== undefined ? templateRequestBody : {}) : (templateRequestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplateApi - functional programming interface
 * @export
 */
export const TemplateApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new Template
         * @param {TemplateRequestBody} templateRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTemplate(templateRequestBody: TemplateRequestBody, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Template> {
            const localVarAxiosArgs = TemplateApiAxiosParamCreator(configuration).addTemplate(templateRequestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes a Template
         * @param {string} templateId Template id to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate(templateId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = TemplateApiAxiosParamCreator(configuration).deleteTemplate(templateId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single template
         * @summary Find Template by ID
         * @param {string} templateId ID of template to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplateById(templateId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Template> {
            const localVarAxiosArgs = TemplateApiAxiosParamCreator(configuration).getTemplateById(templateId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of templates
         * @summary List all Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTemplate(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Template>> {
            const localVarAxiosArgs = TemplateApiAxiosParamCreator(configuration).listTemplate(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a string representing the HTML content of an email to be sent
         * @summary Renders a template using the provided event parameters
         * @param {string} templateId ID of template to return
         * @param {RenderTemplateRequestBody} renderTemplateRequestBody The event parameters used to render
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renderTemplate(templateId: string, renderTemplateRequestBody: RenderTemplateRequestBody, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message> {
            const localVarAxiosArgs = TemplateApiAxiosParamCreator(configuration).renderTemplate(templateId, renderTemplateRequestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update an existing Template
         * @param {string} templateId ID of template to return
         * @param {TemplateRequestBody} templateRequestBody successful operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplate(templateId: string, templateRequestBody: TemplateRequestBody, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Template> {
            const localVarAxiosArgs = TemplateApiAxiosParamCreator(configuration).updateTemplate(templateId, templateRequestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TemplateApi - factory interface
 * @export
 */
export const TemplateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create a new Template
         * @param {TemplateRequestBody} templateRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTemplate(templateRequestBody: TemplateRequestBody, options?: any) {
            return TemplateApiFp(configuration).addTemplate(templateRequestBody, options)(axios, basePath);
        },
        /**
         * 
         * @summary Deletes a Template
         * @param {string} templateId Template id to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate(templateId: string, options?: any) {
            return TemplateApiFp(configuration).deleteTemplate(templateId, options)(axios, basePath);
        },
        /**
         * Returns a single template
         * @summary Find Template by ID
         * @param {string} templateId ID of template to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplateById(templateId: string, options?: any) {
            return TemplateApiFp(configuration).getTemplateById(templateId, options)(axios, basePath);
        },
        /**
         * Returns a list of templates
         * @summary List all Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTemplate(options?: any) {
            return TemplateApiFp(configuration).listTemplate(options)(axios, basePath);
        },
        /**
         * Returns a string representing the HTML content of an email to be sent
         * @summary Renders a template using the provided event parameters
         * @param {string} templateId ID of template to return
         * @param {RenderTemplateRequestBody} renderTemplateRequestBody The event parameters used to render
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renderTemplate(templateId: string, renderTemplateRequestBody: RenderTemplateRequestBody, options?: any) {
            return TemplateApiFp(configuration).renderTemplate(templateId, renderTemplateRequestBody, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update an existing Template
         * @param {string} templateId ID of template to return
         * @param {TemplateRequestBody} templateRequestBody successful operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplate(templateId: string, templateRequestBody: TemplateRequestBody, options?: any) {
            return TemplateApiFp(configuration).updateTemplate(templateId, templateRequestBody, options)(axios, basePath);
        },
    };
};

/**
 * TemplateApi - object-oriented interface
 * @export
 * @class TemplateApi
 * @extends {BaseAPI}
 */
export class TemplateApi extends BaseAPI {
    /**
     * 
     * @summary Create a new Template
     * @param {TemplateRequestBody} templateRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public addTemplate(templateRequestBody: TemplateRequestBody, options?: any) {
        return TemplateApiFp(this.configuration).addTemplate(templateRequestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Deletes a Template
     * @param {string} templateId Template id to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public deleteTemplate(templateId: string, options?: any) {
        return TemplateApiFp(this.configuration).deleteTemplate(templateId, options)(this.axios, this.basePath);
    }

    /**
     * Returns a single template
     * @summary Find Template by ID
     * @param {string} templateId ID of template to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public getTemplateById(templateId: string, options?: any) {
        return TemplateApiFp(this.configuration).getTemplateById(templateId, options)(this.axios, this.basePath);
    }

    /**
     * Returns a list of templates
     * @summary List all Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public listTemplate(options?: any) {
        return TemplateApiFp(this.configuration).listTemplate(options)(this.axios, this.basePath);
    }

    /**
     * Returns a string representing the HTML content of an email to be sent
     * @summary Renders a template using the provided event parameters
     * @param {string} templateId ID of template to return
     * @param {RenderTemplateRequestBody} renderTemplateRequestBody The event parameters used to render
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public renderTemplate(templateId: string, renderTemplateRequestBody: RenderTemplateRequestBody, options?: any) {
        return TemplateApiFp(this.configuration).renderTemplate(templateId, renderTemplateRequestBody, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update an existing Template
     * @param {string} templateId ID of template to return
     * @param {TemplateRequestBody} templateRequestBody successful operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public updateTemplate(templateId: string, templateRequestBody: TemplateRequestBody, options?: any) {
        return TemplateApiFp(this.configuration).updateTemplate(templateId, templateRequestBody, options)(this.axios, this.basePath);
    }

}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This can only be done by the logged in user.
         * @summary Delete user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(options: any = {}): RequestArgs {
            const localVarPath = `/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user info for the currently authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo(options: any = {}): RequestArgs {
            const localVarPath = `/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Google required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("Google", ["https://www.googleapis.com/auth/userinfo.email"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logs user into the system
         * @param {string} username The user name for login
         * @param {string} password The password for login in clear text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser(username: string, password: string, options: any = {}): RequestArgs {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling loginUser.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling loginUser.');
            }
            const localVarPath = `/user/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logs out current logged in user session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser(options: any = {}): RequestArgs {
            const localVarPath = `/user/logout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Updated user
         * @param {UserRequestBody} userRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(userRequestBody: UserRequestBody, options: any = {}): RequestArgs {
            // verify required parameter 'userRequestBody' is not null or undefined
            if (userRequestBody === null || userRequestBody === undefined) {
                throw new RequiredError('userRequestBody','Required parameter userRequestBody was null or undefined when calling updateUser.');
            }
            const localVarPath = `/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"UserRequestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(userRequestBody !== undefined ? userRequestBody : {}) : (userRequestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This can only be done by the logged in user.
         * @summary Delete user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).deleteUser(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get user info for the currently authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).getUserInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Logs user into the system
         * @param {string} username The user name for login
         * @param {string} password The password for login in clear text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser(username: string, password: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).loginUser(username, password, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Logs out current logged in user session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).logoutUser(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Updated user
         * @param {UserRequestBody} userRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(userRequestBody: UserRequestBody, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).updateUser(userRequestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * This can only be done by the logged in user.
         * @summary Delete user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(options?: any) {
            return UserApiFp(configuration).deleteUser(options)(axios, basePath);
        },
        /**
         * 
         * @summary Get user info for the currently authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo(options?: any) {
            return UserApiFp(configuration).getUserInfo(options)(axios, basePath);
        },
        /**
         * 
         * @summary Logs user into the system
         * @param {string} username The user name for login
         * @param {string} password The password for login in clear text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser(username: string, password: string, options?: any) {
            return UserApiFp(configuration).loginUser(username, password, options)(axios, basePath);
        },
        /**
         * 
         * @summary Logs out current logged in user session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser(options?: any) {
            return UserApiFp(configuration).logoutUser(options)(axios, basePath);
        },
        /**
         * This can only be done by the logged in user.
         * @summary Updated user
         * @param {UserRequestBody} userRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(userRequestBody: UserRequestBody, options?: any) {
            return UserApiFp(configuration).updateUser(userRequestBody, options)(axios, basePath);
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * This can only be done by the logged in user.
     * @summary Delete user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUser(options?: any) {
        return UserApiFp(this.configuration).deleteUser(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get user info for the currently authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserInfo(options?: any) {
        return UserApiFp(this.configuration).getUserInfo(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Logs user into the system
     * @param {string} username The user name for login
     * @param {string} password The password for login in clear text
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public loginUser(username: string, password: string, options?: any) {
        return UserApiFp(this.configuration).loginUser(username, password, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Logs out current logged in user session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public logoutUser(options?: any) {
        return UserApiFp(this.configuration).logoutUser(options)(this.axios, this.basePath);
    }

    /**
     * This can only be done by the logged in user.
     * @summary Updated user
     * @param {UserRequestBody} userRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(userRequestBody: UserRequestBody, options?: any) {
        return UserApiFp(this.configuration).updateUser(userRequestBody, options)(this.axios, this.basePath);
    }

}


